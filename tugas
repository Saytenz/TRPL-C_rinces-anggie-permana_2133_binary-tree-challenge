import 'dart:collection';
import 'dart:io';

class Node {
  int value;
  Node? left;
  Node? right;

  Node(this.value);
}

class BinaryTree {
  Node? root;

  // Tambah node dengan Level Order (menggunakan Queue)
  void insertLevelOrder(int value) {
    Node newNode = Node(value);

    if (root == null) {
      root = newNode;
      return;
    }

    Queue<Node> queue = Queue<Node>();
    queue.add(root!);

    while (queue.isNotEmpty) {
      Node current = queue.removeFirst();

      if (current.left == null) {
        current.left = newNode;
        return;
      } else {
        queue.add(current.left!);
      }

      if (current.right == null) {
        current.right = newNode;
        return;
      } else {
        queue.add(current.right!);
      }
    }
  }

  // Tambah node berdasarkan target value (linear search)
  bool insertByTarget(int target, int newValue) {
    if (root == null) return false;

    Queue<Node> queue = Queue<Node>();
    queue.add(root!);

    while (queue.isNotEmpty) {
      Node current = queue.removeFirst();

      if (current.value == target) {
        if (current.left == null) {
          current.left = Node(newValue);
        } else if (current.right == null) {
          current.right = Node(newValue);
        } else {
          print("Target node sudah punya 2 anak.");
          return false;
        }
        return true;
      }

      if (current.left != null) queue.add(current.left!);
      if (current.right != null) queue.add(current.right!);
    }

    print("Target tidak ditemukan.");
    return false;
  }

  // InOrder traversal tanpa rekursi
  void inOrderNonRecursive() {
    List<Node> stack = [];
    Node? current = root;

    print("InOrder Non-Recursive:");
    while (current != null || stack.isNotEmpty) {
      while (current != null) {
        stack.add(current);
        current = current.left;
      }
      current = stack.removeLast();
      stdout.write("${current.value} ");
      current = current.right;
    }
    print("");
  }

  // PreOrder traversal tanpa rekursi
  void preOrderNonRecursive() {
    if (root == null) return;

    List<Node> stack = [root!];

    print("PreOrder Non-Recursive:");
    while (stack.isNotEmpty) {
      Node current = stack.removeLast();
      stdout.write("${current.value} ");

      if (current.right != null) stack.add(current.right!);
      if (current.left != null) stack.add(current.left!);
    }
    print("");
  }

  // PostOrder traversal tanpa rekursi
  void postOrderNonRecursive() {
    if (root == null) return;

    List<Node> stack1 = [root!];
    List<int> output = [];

    while (stack1.isNotEmpty) {
      Node current = stack1.removeLast();
      output.add(current.value);

      if (current.left != null) stack1.add(current.left!);
      if (current.right != null) stack1.add(current.right!);
    }

    output = output.reversed.toList();
    print("PostOrder Non-Recursive:");
    for (int val in output) {
      stdout.write("$val ");
    }
    print("");
  }
}

void main() {
  BinaryTree tree = BinaryTree();

  // Tambah node secara level-order
  tree.insertLevelOrder(10);
  tree.insertLevelOrder(20);
  tree.insertLevelOrder(30);
  tree.insertLevelOrder(40);
  tree.insertLevelOrder(50);

  // Tambah node berdasarkan target (misalnya ingin menambahkan anak ke node 30)
  tree.insertByTarget(30, 60);
  tree.insertByTarget(30, 70);

  // Traversal tanpa rekursi
  tree.inOrderNonRecursive();   // Output bisa: 40 20 50 10 60 30 70
  tree.preOrderNonRecursive();  // Output: 10 20 40 50 30 60 70
  tree.postOrderNonRecursive(); // Output: 40 50 20 60 70 30 10
}
